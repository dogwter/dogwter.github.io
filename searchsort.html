<!DOCTYPE html>
<html lang = "en">

<head>
    <title> portfolio </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link href='https://fonts.googleapis.com/css?family=Inter' rel='stylesheet'>
    <link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet'>
    <link rel="stylesheet" href="oop.css">
    <link rel="stylesheet" href="nav.css">
    <link rel="stylesheet" href="rss.css">
</head>

<body>
  <nav class="navbar sticky-top navbar-expand-lg navbar-dark bg-dark">
    <a class="navbar-brand" href="#">Portfolio</a>
    <li class = "icon">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill = "#FFFFFF" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
    </li>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNavDropdown">
      <ul class="navbar-nav">
        <li class="nav-item active">
          <a class="nav-link" href="index.html"> home <span class="sr-only"></span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="about.html">about</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="projects.html">projects</a>
        </li>
        <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              java
            </a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
              <div class = "text">
                <a class="dropdown-title" href="#">learning</a>
                <a class="dropdown-item" href="oop.html">OOP</a>
                <a class="dropdown-item" href="arrays.html">arrays</a>
                <a class="dropdown-item" href="arraylist.html">arraylists</a>
                <a class="dropdown-item" href="searchsort.html">search & sort</a>
                <a class="dropdown-item" href="recursion.html">recursion</a>
              </div>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="sources.html">sources</a>
        </li>
      </ul>
    </div>
  </nav>
  <div class = "nof">
  <div class="tutorial">
    <div class ="tutorial-body" style="float:left">
      <p class = tutorial-title>search and sort</p>
      <a class = "basics">Search and Sort</a>
      <p></p>
      <p class = "body">Searching and sorting data is one of the most common applications of programming.<br>
        This is most commonly used with arrays and arraylists. 
      </p>
      <p id = "search"><br></p>
      <a class = "basics">Searching</a>
      <p></p>
      <p class = "body">Searching is when a program looks for the location or index of a specific element or value. 
        This assumes the data structure is already sorted in ascending or descending order.
      </p>
      <p class = "spacer"> </p>
      <p class = subtitle>Sequential Search</p>
      <p class = "body">Sequential search iterates through every single element of the data and compares each element to the desired element until the desired one is found, or it has looked through every element in the data. If the element does not exist in the data, <b>-1</b> is returned.</p>
      <p class = "body">This algorithm does not take advantage of the sorted array and is inefficient, since it may need to search every single element in the data to find out if an element is present. However, it doesn't need the data to be sorted.</p>
      <p class = "body">The best case occurs when the desired element is the first value in the array or arraylist. The worst case occurs when the desired element is either not present or at the very end or the array or arraylist, as every single element in the data must be iterated through.</p>
      <p class = "body">The time complexity of sequential search is O(n).</p>
      <p class = "body">Implementation example of sequential search:</p>
        <pre class = "codes">
          <code>
    public int seqSearch(E[] arr, E element) { 
      for (int i = 0; i < arr.length; i ++) { <b>// loops through arr to find E element</b>
        if (arr[i].equals(element)) {
          return i; <b>// if the element is found, its position is returned</b>
        }
      }
        return -1;  <b>// if the element is not in the data, return -1</b>
    }</code>
      </pre>
      <p class = "spacer"> </p>
      <p class = subtitle>Binary Search</p>
      <p class = "body">Binary search is a much more efficient algorithm than sequential search. It starts by comparing the middle element of the data to the desired element and then halves the remaining amount of data needed to be searched through each time until the element is found or no data remains to be searched.</p>
      <p class = "body">Since the data is sorted, the algorithm can efficiently reduce the range each time by getting rid of the higher/lower half of the remaining data, hence the name binary search.</p>
      <p class = "body">This algorithm has time complexity O(log n).</p>
      <p class = "body">There are two ways to implement this algorithm, as it can be done with iteration using a while loop or with recursion.</p>
      <p class = "body">Iterative example:</p>
      <pre class = "codes">
        <code>
    public int binarySearch(int [] arr, int element) {  <b>// finding element in integer array arr</b>
      int x = 0, y = arr.length-1;
        while (x <= y) {  <b>// while there is still data to be searched</b>
          int m = x + (y - x) / 2;
          
          if (arr[m] == x) return m; <b>// return the index if the element is found</b>
          
          if (array[m] < x) x = m - 1; <b>// halve range accordingly</b>
          else y = m + 1;
        }
          
        return -1; <b>// return -1 if element was not in the data</b>
    }</code>
    </pre>
    <p class = "spacer"></p>
    <p class = "body">Recursive Example:</p>
    <pre class = "codes">
      <code>
    public int binarySearch(int arr[], int x, int a, int b) {

      if (b >= a) { <b>// if there is still data to be searched</b>
            int m = a + (b - a) / 2;
      
            if (arr[m] == x) return m; <b>// base case: return the index if the element is found</b>
      
            if (arr[m] > x) return binarySearch(array, x, a, m - 1); <b>// halve range accordingly</b>
            else return binarySearch(arr, x, m + 1, y);
      }
      
      return -1; <b>// return -1 if element was not in the data</b>

    }</code>
    </pre>
    <p class = "spacer"></p>
    <p class = "body">If you are not familiar with recursion, check out <a class = "link" href = "recursion.html">my tutorial</a>.</p>
    <p id = "sort"><br></p>
    <a class = "basics">Sorting</a>
    <p></p>
      <p class = "body">Sorting is when a program organizes comparable elements of the same type in ascending or descending order.<br>
        This allows for more efficient searching, as previously mentioned. There are recursive and non-recursive sorting algorithms of varying efficiencies.
      </p>
      <p class = "spacer"> </p>
      <p class = "subtitle">Bubble Sort</p>
      <p class = "body">Bubble Sort is a simple sorting algorithm that repeatedly iterates through data by comparing each pair of adjacent elements, and swapping them if they are in the wrong order. The algorithm gets its name from the way the elements "bubble" to the top of the list with each full pass. For each full pass, the range of data which needs to be passed through decreases by 1, until there is a pass where no swaps are made and the data is fully sorted.</p>
      <p class = "body"></p>
    </div>

    <div class = "tutorial-nav">
      <p class = "nav-subtitle">JUMP TO</p>
      <a class = "nav-option" href="#"> The Basics</a>
      <a class = "nav-option" href="#search"> Searching</a>
      <a class = "nav-option" href = "#sort">Sorting</a>
      <a class = "nav-option" href="#">Complexity</a>
    </div>

  </div>
</div>
  <div class = "footer"> copyright 2023 ahuang</div>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
</body>

</html>